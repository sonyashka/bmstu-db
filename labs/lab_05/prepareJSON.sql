-- 1 - извлечь данные из базы данных в json
select row_to_json(s)
from student s

select row_to_json(t)
from teacher t 

select row_to_json(c)
from composer c 

select row_to_json(c)
from composition c 

select row_to_json(e)
from exam e 

-- 2 - выполнить загрузку и сохранение json-файла в таблицу
-- созданная таблица должна соответствовать исходным данным
create table sc1.CompositionCopy(
	id int generated by default as identity 
	(start with 1 increment by 1) primary key,
	title text not null,
	tonality text not null, 
	amount int check (amount > 0),
	composerid int not null references sc1.Composer (id)
)

copy (
	select row_to_json(c)
	from composition c 
) to '/tmp/composition.json'

create table sc1.compositionImport(doc json)

copy compositionImport from '/tmp/composition.json'

select *
from compositionImport

insert into compositionCopy
select id, title, tonality, amount, composerid
from compositionimport, json_populate_record(null::compositionCopy, doc)

select *
from compositionCopy

-- 3 - создать таблицу с атрибутом типа json или добавить такой атрибут
-- в уже существующую таблицу. Заполнить атрибут правдоподобными данными
-- с помощью команд insert или update
alter table sc1.teacher 
add column salary json

update sc1.teacher 
set salary = json_object('{bet, studentnum}', '{150, 10}')

select *
from sc1.teacher t 

-- 4 - выполнить следующие действия:
-- 1) извлечь json фрагмент из json документа
create table sc1.compositionReduced(
	id int,
	title text,
	tonality text
)

select *
from compositionImport, json_populate_record(null::compositionReduced, doc)

select doc->'id' as id, doc->'title' as title, doc->'tonality' as tonality
from compositionImport

-- 2) извлечь значения конкретных узлов или атрибутов json документа
create table sc1.studentHobby(
	doc json
)

insert into sc1.studentHobby
values ('{"id": 2, "hobby": {"beginner":"компьютерные игры", "expert":"лего"}}')

insert into sc1.studentHobby
values ('{"id": 4, "hobby": {"beginner":"футбол", "expert":"рисование"}}')

select doc->'id' as id, doc->'hobby'->'expert' as expertIn
from studentHobby

-- 3) выполнить проверку существования узла или атрибута
drop function findHobby(sid json)

create or replace function findHobby(sid json)
returns text as 
$$
declare 
	find text;
	cnt int;
begin
	select count(*)
	from sc1.studentHobby into cnt
	where (doc->'id')::int = sid::int;
	if cnt > 0 then
		find = 'exist';
	else
		find = 'not exist';
	end if;
	return find;
end
$$
language plpgsql

select '1' as studentid, findHobby('1') as hobby

-- 4) изменить json документ
update studenthobby 
set doc = doc::jsonb || '{"id": 10}'::jsonb
where (doc->'id')::text = 2::text

select *
from studenthobby

-- 5) разделить json документ на несколько строк поузлам
create table sc1.teacherFriend(
	doc json
)

insert into teacherFriend
values ('[{"id": 1, "friendid": 4}, {"id": 6, "friendid": 1},
	 {"id": 11, "friendid": 4}]')
	 
select json_array_elements(doc::json)
from teacherFriend

-- защита: вывести названия произведений, сыграных в определенную дату на экзамене
-- найти питоном, вывести в json
drop function conDateTitle(dt text)

create function conDateTitle(dt text)
returns json as
$$
	import json
	exam = plpy.execute("select date, title\
		from exam e join composition c on e.compositionid = c.id\
		where date::text like '" + str(dt) + "'")
	res = []
	for elem in exam:
		res.append(elem["title"])
	resjson = json.dumps('{"title": res}')
	return resjson
$$
language plpython3u

select distinct e.date, conDateTitle(e.date::text)
from sc1.exam e
where e.date::text like '2021-06-19'
